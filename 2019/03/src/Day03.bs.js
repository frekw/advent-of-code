// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Belt_Map = require("bs-platform/lib/js/belt_Map.js");
var Belt_Set = require("bs-platform/lib/js/belt_Set.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Belt_Option = require("bs-platform/lib/js/belt_Option.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var RList$Rationale = require("rationale/src/RList.js");
var Function$Rationale = require("rationale/src/Function.js");
var Input$MyNewProject = require("./Input.bs.js");

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var T = Belt_Id.MakeComparable({
      cmp: cmp
    });

function combine(xs) {
  return Belt_List.reduceReverse(xs, /* [] */0, (function (acc, x) {
                return Belt_Option.flatMap(acc, (function (xs) {
                              return Belt_Option.map(x, (function (x) {
                                            return /* :: */[
                                                    x,
                                                    xs
                                                  ];
                                          }));
                            }));
              }));
}

function split(param, param$1) {
  return Function$Rationale.flip((function (prim, prim$1) {
                return prim$1.split(prim);
              }), param, param$1);
}

function parseSegment(str) {
  var repeat = function (t, n) {
    return RList$Rationale.repeat(t, Caml_format.caml_int_of_string(n));
  };
  var op = str.slice(0, 1);
  var v = str.slice(1);
  switch (op) {
    case "D" :
        return repeat(/* tuple */[
                    0,
                    -1
                  ], v);
    case "L" :
        return repeat(/* tuple */[
                    -1,
                    0
                  ], v);
    case "R" :
        return repeat(/* tuple */[
                    1,
                    0
                  ], v);
    case "U" :
        return repeat(/* tuple */[
                    0,
                    1
                  ], v);
    default:
      return ;
  }
}

function parsePath(x) {
  return Belt_List.flatten(Belt_Option.getWithDefault(combine(Belt_List.map(Belt_List.fromArray(split(x, ",")), parseSegment)), /* [] */0));
}

function step(a, b) {
  var match = a > b;
  if (match) {
    return RList$Rationale.rangeInt(1)(b, a);
  } else {
    return RList$Rationale.rangeInt(1)(a, b);
  }
}

function coordinates(segments) {
  var map = Belt_Map.make(T);
  return Belt_List.reduce(segments, /* tuple */[
                /* tuple */[
                  0,
                  0
                ],
                1,
                map
              ], (function (param, param$1) {
                  var map = param[2];
                  var steps = param[1];
                  var match = param[0];
                  var next_000 = match[0] + param$1[0] | 0;
                  var next_001 = match[1] + param$1[1] | 0;
                  var next = /* tuple */[
                    next_000,
                    next_001
                  ];
                  var match$1 = Belt_Map.has(map, next);
                  if (match$1) {
                    return /* tuple */[
                            next,
                            steps + 1 | 0,
                            map
                          ];
                  } else {
                    return /* tuple */[
                            next,
                            steps + 1 | 0,
                            Belt_Map.set(map, next, steps)
                          ];
                  }
                }))[2];
}

function closest(m1, m2) {
  var p1 = Belt_Set.fromArray(Belt_Map.keysToArray(m1), T);
  var p2 = Belt_Set.fromArray(Belt_Map.keysToArray(m2), T);
  var get = function (m, k) {
    return Belt_Option.getWithDefault(Belt_Map.get(m, k), 0);
  };
  return Belt_List.reduce(Belt_List.map(Belt_Set.toList(Belt_Set.intersect(p1, p2)), (function (p) {
                    return get(m1, p) + get(m2, p) | 0;
                  })), Pervasives.max_int, (function (current, d) {
                var match = d < current;
                if (match) {
                  return d;
                } else {
                  return current;
                }
              }));
}

function run(input) {
  var paths = Belt_List.map(Belt_List.map(Belt_List.fromArray(split(input, "\n")), parsePath), coordinates);
  if (paths) {
    var match = paths[1];
    if (match && !match[1]) {
      return closest(paths[0], match[0]);
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}

console.log(run(Input$MyNewProject.input));

exports.T = T;
exports.combine = combine;
exports.split = split;
exports.parseSegment = parseSegment;
exports.parsePath = parsePath;
exports.step = step;
exports.coordinates = coordinates;
exports.closest = closest;
exports.run = run;
/* T Not a pure module */
